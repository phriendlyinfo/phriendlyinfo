// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  require.define('/components/search/index.client.js', function (module, exports, __dirname, __filename) {
    var Backbone = require('/node_modules/backbone/backbone.js', module);
    Backbone.$ || (Backbone.$ = jQuery);
    var Router = require('/components/search/router.client.js', module);
    $(function () {
      new Router;
    });
  });
  require.define('/components/search/router.client.js', function (module, exports, __dirname, __filename) {
    var Backbone = require('/node_modules/backbone/backbone.js', module), FormView = require('/components/search/views/form.js', module), Parser = require('/components/search/parser.js', module), Result = require('/components/search/result.client.js', module), Results = require('/components/search/results.client.js', module), ResultsView = require('/components/search/views/results.js', module);
    module.exports = Backbone.Router.extend({
      routes: {},
      initialize: function () {
        var form = this.form = new FormView({ el: $('#js-search-form-container') });
        form.render();
        form.on('submit', this.handleSubmit, this);
        this.results = new Results({ model: Result });
        var resultsView = new ResultsView({ el: $('#js-content') });
        this.results.on('reset', function (collection) {
          resultsView.render(collection.models);
        }, this);
      },
      handleSubmit: function (search) {
        try {
          var parsedSearch = Parser.parse(search);
        } catch (e) {
          this.form.trigger('error', {
            message: 'malformed search',
            error: e.message
          });
          return;
        }
        this.results.fetch(parsedSearch);
      }
    });
  });
  require.define('/components/search/views/results.js', function (module, exports, __dirname, __filename) {
    var Backbone = require('/node_modules/backbone/backbone.js', module), Results = require('/components/search/views/react/results.js', module);
    module.exports = Backbone.View.extend({
      render: function (results) {
        React.renderComponent(Results({ results: results }), this.$el[0]);
      }
    });
  });
  require.define('/components/search/views/react/results.js', function (module, exports, __dirname, __filename) {
    module.exports = React.createClass({
      displayName: 'exports',
      render: function () {
        return React.DOM.section({ className: 'results' }, React.DOM.ul(null, this.props.results.map(function (result) {
          return React.DOM.li(null, React.DOM.span({ className: 'date' }, result.get('humanDate')), React.DOM.span({ className: 'location' }, result.get('venue').name, ' ', React.DOM.br(null), result.get('venue').location.city, ', ', result.get('venue').location.state));
        }, this)));
      }
    });
  });
  require.define('/node_modules/backbone/backbone.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        define([
          'underscore',
          'jquery',
          'exports'
        ], function (_, $, exports) {
          root.Backbone = factory(root, exports, _, $);
        });
      } else if (typeof exports !== 'undefined') {
        var _ = require('/node_modules/underscore/underscore.js', module);
        factory(root, exports, _);
      } else {
        root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
      }
    }(this, function (root, Backbone, _, $) {
      var previousBackbone = root.Backbone;
      var array = [];
      var push = array.push;
      var slice = array.slice;
      var splice = array.splice;
      Backbone.VERSION = '1.1.2';
      Backbone.$ = $;
      Backbone.noConflict = function () {
        root.Backbone = previousBackbone;
        return this;
      };
      Backbone.emulateHTTP = false;
      Backbone.emulateJSON = false;
      var Events = Backbone.Events = {
          on: function (name, callback, context) {
            if (!eventsApi(this, 'on', name, [
                callback,
                context
              ]) || !callback)
              return this;
            this._events || (this._events = {});
            var events = this._events[name] || (this._events[name] = []);
            events.push({
              callback: callback,
              context: context,
              ctx: context || this
            });
            return this;
          },
          once: function (name, callback, context) {
            if (!eventsApi(this, 'once', name, [
                callback,
                context
              ]) || !callback)
              return this;
            var self = this;
            var once = _.once(function () {
                self.off(name, once);
                callback.apply(this, arguments);
              });
            once._callback = callback;
            return this.on(name, once, context);
          },
          off: function (name, callback, context) {
            var retain, ev, events, names, i, l, j, k;
            if (!this._events || !eventsApi(this, 'off', name, [
                callback,
                context
              ]))
              return this;
            if (!name && !callback && !context) {
              this._events = void 0;
              return this;
            }
            names = name ? [name] : _.keys(this._events);
            for (i = 0, l = names.length; i < l; i++) {
              name = names[i];
              if (events = this._events[name]) {
                this._events[name] = retain = [];
                if (callback || context) {
                  for (j = 0, k = events.length; j < k; j++) {
                    ev = events[j];
                    if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                      retain.push(ev);
                    }
                  }
                }
                if (!retain.length)
                  delete this._events[name];
              }
            }
            return this;
          },
          trigger: function (name) {
            if (!this._events)
              return this;
            var args = slice.call(arguments, 1);
            if (!eventsApi(this, 'trigger', name, args))
              return this;
            var events = this._events[name];
            var allEvents = this._events.all;
            if (events)
              triggerEvents(events, args);
            if (allEvents)
              triggerEvents(allEvents, arguments);
            return this;
          },
          stopListening: function (obj, name, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo)
              return this;
            var remove = !name && !callback;
            if (!callback && typeof name === 'object')
              callback = this;
            if (obj)
              (listeningTo = {})[obj._listenId] = obj;
            for (var id in listeningTo) {
              obj = listeningTo[id];
              obj.off(name, callback, this);
              if (remove || _.isEmpty(obj._events))
                delete this._listeningTo[id];
            }
            return this;
          }
        };
      var eventSplitter = /\s+/;
      var eventsApi = function (obj, action, name, rest) {
        if (!name)
          return true;
        if (typeof name === 'object') {
          for (var key in name) {
            obj[action].apply(obj, [
              key,
              name[key]
            ].concat(rest));
          }
          return false;
        }
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          for (var i = 0, l = names.length; i < l; i++) {
            obj[action].apply(obj, [names[i]].concat(rest));
          }
          return false;
        }
        return true;
      };
      var triggerEvents = function (events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
        case 0:
          while (++i < l)
            (ev = events[i]).callback.call(ev.ctx);
          return;
        case 1:
          while (++i < l)
            (ev = events[i]).callback.call(ev.ctx, a1);
          return;
        case 2:
          while (++i < l)
            (ev = events[i]).callback.call(ev.ctx, a1, a2);
          return;
        case 3:
          while (++i < l)
            (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
          return;
        default:
          while (++i < l)
            (ev = events[i]).callback.apply(ev.ctx, args);
          return;
        }
      };
      var listenMethods = {
          listenTo: 'on',
          listenToOnce: 'once'
        };
      _.each(listenMethods, function (implementation, method) {
        Events[method] = function (obj, name, callback) {
          var listeningTo = this._listeningTo || (this._listeningTo = {});
          var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
          listeningTo[id] = obj;
          if (!callback && typeof name === 'object')
            callback = this;
          obj[implementation](name, callback, this);
          return this;
        };
      });
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _.extend(Backbone, Events);
      var Model = Backbone.Model = function (attributes, options) {
          var attrs = attributes || {};
          options || (options = {});
          this.cid = _.uniqueId('c');
          this.attributes = {};
          if (options.collection)
            this.collection = options.collection;
          if (options.parse)
            attrs = this.parse(attrs, options) || {};
          attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
          this.set(attrs, options);
          this.changed = {};
          this.initialize.apply(this, arguments);
        };
      _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: 'id',
        initialize: function () {
        },
        toJSON: function (options) {
          return _.clone(this.attributes);
        },
        sync: function () {
          return Backbone.sync.apply(this, arguments);
        },
        get: function (attr) {
          return this.attributes[attr];
        },
        escape: function (attr) {
          return _.escape(this.get(attr));
        },
        has: function (attr) {
          return this.get(attr) != null;
        },
        set: function (key, val, options) {
          var attr, attrs, unset, changes, silent, changing, prev, current;
          if (key == null)
            return this;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          unset = options.unset;
          silent = options.silent;
          changes = [];
          changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
          }
          current = this.attributes, prev = this._previousAttributes;
          if (this.idAttribute in attrs)
            this.id = attrs[this.idAttribute];
          for (attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val))
              changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
              this.changed[attr] = val;
            } else {
              delete this.changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i = 0, l = changes.length; i < l; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        unset: function (attr, options) {
          return this.set(attr, void 0, _.extend({}, options, { unset: true }));
        },
        clear: function (options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, { unset: true }));
        },
        hasChanged: function (attr) {
          if (attr == null)
            return !_.isEmpty(this.changed);
          return _.has(this.changed, attr);
        },
        changedAttributes: function (diff) {
          if (!diff)
            return this.hasChanged() ? _.clone(this.changed) : false;
          var val, changed = false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          for (var attr in diff) {
            if (_.isEqual(old[attr], val = diff[attr]))
              continue;
            (changed || (changed = {}))[attr] = val;
          }
          return changed;
        },
        previous: function (attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        previousAttributes: function () {
          return _.clone(this._previousAttributes);
        },
        fetch: function (options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0)
            options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function (resp) {
            if (!model.set(model.parse(resp, options), options))
              return false;
            if (success)
              success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        save: function (key, val, options) {
          var attrs, method, xhr, attributes = this.attributes;
          if (key == null || typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _.extend({ validate: true }, options);
          if (attrs && !options.wait) {
            if (!this.set(attrs, options))
              return false;
          } else {
            if (!this._validate(attrs, options))
              return false;
          }
          if (attrs && options.wait) {
            this.attributes = _.extend({}, attributes, attrs);
          }
          if (options.parse === void 0)
            options.parse = true;
          var model = this;
          var success = options.success;
          options.success = function (resp) {
            model.attributes = attributes;
            var serverAttrs = model.parse(resp, options);
            if (options.wait)
              serverAttrs = _.extend(attrs || {}, serverAttrs);
            if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
              return false;
            }
            if (success)
              success(model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
          if (method === 'patch')
            options.attrs = attrs;
          xhr = this.sync(method, this, options);
          if (attrs && options.wait)
            this.attributes = attributes;
          return xhr;
        },
        destroy: function (options) {
          options = options ? _.clone(options) : {};
          var model = this;
          var success = options.success;
          var destroy = function () {
            model.trigger('destroy', model, model.collection, options);
          };
          options.success = function (resp) {
            if (options.wait || model.isNew())
              destroy();
            if (success)
              success(model, resp, options);
            if (!model.isNew())
              model.trigger('sync', model, resp, options);
          };
          if (this.isNew()) {
            options.success();
            return false;
          }
          wrapError(this, options);
          var xhr = this.sync('delete', this, options);
          if (!options.wait)
            destroy();
          return xhr;
        },
        url: function () {
          var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
          if (this.isNew())
            return base;
          return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
        },
        parse: function (resp, options) {
          return resp;
        },
        clone: function () {
          return new this.constructor(this.attributes);
        },
        isNew: function () {
          return !this.has(this.idAttribute);
        },
        isValid: function (options) {
          return this._validate({}, _.extend(options || {}, { validate: true }));
        },
        _validate: function (attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
          return false;
        }
      });
      var modelMethods = [
          'keys',
          'values',
          'pairs',
          'invert',
          'pick',
          'omit'
        ];
      _.each(modelMethods, function (method) {
        Model.prototype[method] = function () {
          var args = slice.call(arguments);
          args.unshift(this.attributes);
          return _[method].apply(_, args);
        };
      });
      var Collection = Backbone.Collection = function (models, options) {
          options || (options = {});
          if (options.model)
            this.model = options.model;
          if (options.comparator !== void 0)
            this.comparator = options.comparator;
          this._reset();
          this.initialize.apply(this, arguments);
          if (models)
            this.reset(models, _.extend({ silent: true }, options));
        };
      var setOptions = {
          add: true,
          remove: true,
          merge: true
        };
      var addOptions = {
          add: true,
          remove: false
        };
      _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function () {
        },
        toJSON: function (options) {
          return this.map(function (model) {
            return model.toJSON(options);
          });
        },
        sync: function () {
          return Backbone.sync.apply(this, arguments);
        },
        add: function (models, options) {
          return this.set(models, _.extend({ merge: false }, options, addOptions));
        },
        remove: function (models, options) {
          var singular = !_.isArray(models);
          models = singular ? [models] : _.clone(models);
          options || (options = {});
          var i, l, index, model;
          for (i = 0, l = models.length; i < l; i++) {
            model = models[i] = this.get(models[i]);
            if (!model)
              continue;
            delete this._byId[model.id];
            delete this._byId[model.cid];
            index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            if (!options.silent) {
              options.index = index;
              model.trigger('remove', model, this, options);
            }
            this._removeReference(model, options);
          }
          return singular ? models[0] : models;
        },
        set: function (models, options) {
          options = _.defaults({}, options, setOptions);
          if (options.parse)
            models = this.parse(models, options);
          var singular = !_.isArray(models);
          models = singular ? models ? [models] : [] : _.clone(models);
          var i, l, id, model, attrs, existing, sort;
          var at = options.at;
          var targetModel = this.model;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _.isString(this.comparator) ? this.comparator : null;
          var toAdd = [], toRemove = [], modelMap = {};
          var add = options.add, merge = options.merge, remove = options.remove;
          var order = !sortable && add && remove ? [] : false;
          for (i = 0, l = models.length; i < l; i++) {
            attrs = models[i] || {};
            if (attrs instanceof Model) {
              id = model = attrs;
            } else {
              id = attrs[targetModel.prototype.idAttribute || 'id'];
            }
            if (existing = this.get(id)) {
              if (remove)
                modelMap[existing.cid] = true;
              if (merge) {
                attrs = attrs === model ? model.attributes : attrs;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                if (sortable && !sort && existing.hasChanged(sortAttr))
                  sort = true;
              }
              models[i] = existing;
            } else if (add) {
              model = models[i] = this._prepareModel(attrs, options);
              if (!model)
                continue;
              toAdd.push(model);
              this._addReference(model, options);
            }
            model = existing || model;
            if (order && (model.isNew() || !modelMap[model.id]))
              order.push(model);
            modelMap[model.id] = true;
          }
          if (remove) {
            for (i = 0, l = this.length; i < l; ++i) {
              if (!modelMap[(model = this.models[i]).cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this.remove(toRemove, options);
          }
          if (toAdd.length || order && order.length) {
            if (sortable)
              sort = true;
            this.length += toAdd.length;
            if (at != null) {
              for (i = 0, l = toAdd.length; i < l; i++) {
                this.models.splice(at + i, 0, toAdd[i]);
              }
            } else {
              if (order)
                this.models.length = 0;
              var orderedModels = order || toAdd;
              for (i = 0, l = orderedModels.length; i < l; i++) {
                this.models.push(orderedModels[i]);
              }
            }
          }
          if (sort)
            this.sort({ silent: true });
          if (!options.silent) {
            for (i = 0, l = toAdd.length; i < l; i++) {
              (model = toAdd[i]).trigger('add', model, this, options);
            }
            if (sort || order && order.length)
              this.trigger('sort', this, options);
          }
          return singular ? models[0] : models;
        },
        reset: function (models, options) {
          options || (options = {});
          for (var i = 0, l = this.models.length; i < l; i++) {
            this._removeReference(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _.extend({ silent: true }, options));
          if (!options.silent)
            this.trigger('reset', this, options);
          return models;
        },
        push: function (model, options) {
          return this.add(model, _.extend({ at: this.length }, options));
        },
        pop: function (options) {
          var model = this.at(this.length - 1);
          this.remove(model, options);
          return model;
        },
        unshift: function (model, options) {
          return this.add(model, _.extend({ at: 0 }, options));
        },
        shift: function (options) {
          var model = this.at(0);
          this.remove(model, options);
          return model;
        },
        slice: function () {
          return slice.apply(this.models, arguments);
        },
        get: function (obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
        },
        at: function (index) {
          return this.models[index];
        },
        where: function (attrs, first) {
          if (_.isEmpty(attrs))
            return first ? void 0 : [];
          return this[first ? 'find' : 'filter'](function (model) {
            for (var key in attrs) {
              if (attrs[key] !== model.get(key))
                return false;
            }
            return true;
          });
        },
        findWhere: function (attrs) {
          return this.where(attrs, true);
        },
        sort: function (options) {
          if (!this.comparator)
            throw new Error('Cannot sort a set without a comparator');
          options || (options = {});
          if (_.isString(this.comparator) || this.comparator.length === 1) {
            this.models = this.sortBy(this.comparator, this);
          } else {
            this.models.sort(_.bind(this.comparator, this));
          }
          if (!options.silent)
            this.trigger('sort', this, options);
          return this;
        },
        pluck: function (attr) {
          return _.invoke(this.models, 'get', attr);
        },
        fetch: function (options) {
          options = options ? _.clone(options) : {};
          if (options.parse === void 0)
            options.parse = true;
          var success = options.success;
          var collection = this;
          options.success = function (resp) {
            var method = options.reset ? 'reset' : 'set';
            collection[method](resp, options);
            if (success)
              success(collection, resp, options);
            collection.trigger('sync', collection, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        create: function (model, options) {
          options = options ? _.clone(options) : {};
          if (!(model = this._prepareModel(model, options)))
            return false;
          if (!options.wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function (model, resp) {
            if (options.wait)
              collection.add(model, options);
            if (success)
              success(model, resp, options);
          };
          model.save(null, options);
          return model;
        },
        parse: function (resp, options) {
          return resp;
        },
        clone: function () {
          return new this.constructor(this.models);
        },
        _reset: function () {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        _prepareModel: function (attrs, options) {
          if (attrs instanceof Model)
            return attrs;
          options = options ? _.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger('invalid', this, model.validationError, options);
          return false;
        },
        _addReference: function (model, options) {
          this._byId[model.cid] = model;
          if (model.id != null)
            this._byId[model.id] = model;
          if (!model.collection)
            model.collection = this;
          model.on('all', this._onModelEvent, this);
        },
        _removeReference: function (model, options) {
          if (this === model.collection)
            delete model.collection;
          model.off('all', this._onModelEvent, this);
        },
        _onModelEvent: function (event, model, collection, options) {
          if ((event === 'add' || event === 'remove') && collection !== this)
            return;
          if (event === 'destroy')
            this.remove(model, options);
          if (model && event === 'change:' + model.idAttribute) {
            delete this._byId[model.previous(model.idAttribute)];
            if (model.id != null)
              this._byId[model.id] = model;
          }
          this.trigger.apply(this, arguments);
        }
      });
      var methods = [
          'forEach',
          'each',
          'map',
          'collect',
          'reduce',
          'foldl',
          'inject',
          'reduceRight',
          'foldr',
          'find',
          'detect',
          'filter',
          'select',
          'reject',
          'every',
          'all',
          'some',
          'any',
          'include',
          'contains',
          'invoke',
          'max',
          'min',
          'toArray',
          'size',
          'first',
          'head',
          'take',
          'initial',
          'rest',
          'tail',
          'drop',
          'last',
          'without',
          'difference',
          'indexOf',
          'shuffle',
          'lastIndexOf',
          'isEmpty',
          'chain',
          'sample'
        ];
      _.each(methods, function (method) {
        Collection.prototype[method] = function () {
          var args = slice.call(arguments);
          args.unshift(this.models);
          return _[method].apply(_, args);
        };
      });
      var attributeMethods = [
          'groupBy',
          'countBy',
          'sortBy',
          'indexBy'
        ];
      _.each(attributeMethods, function (method) {
        Collection.prototype[method] = function (value, context) {
          var iterator = _.isFunction(value) ? value : function (model) {
              return model.get(value);
            };
          return _[method](this.models, iterator, context);
        };
      });
      var View = Backbone.View = function (options) {
          this.cid = _.uniqueId('view');
          options || (options = {});
          _.extend(this, _.pick(options, viewOptions));
          this._ensureElement();
          this.initialize.apply(this, arguments);
          this.delegateEvents();
        };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = [
          'model',
          'collection',
          'el',
          'id',
          'attributes',
          'className',
          'tagName',
          'events'
        ];
      _.extend(View.prototype, Events, {
        tagName: 'div',
        $: function (selector) {
          return this.$el.find(selector);
        },
        initialize: function () {
        },
        render: function () {
          return this;
        },
        remove: function () {
          this.$el.remove();
          this.stopListening();
          return this;
        },
        setElement: function (element, delegate) {
          if (this.$el)
            this.undelegateEvents();
          this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
          this.el = this.$el[0];
          if (delegate !== false)
            this.delegateEvents();
          return this;
        },
        delegateEvents: function (events) {
          if (!(events || (events = _.result(this, 'events'))))
            return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method))
              method = this[events[key]];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            var eventName = match[1], selector = match[2];
            method = _.bind(method, this);
            eventName += '.delegateEvents' + this.cid;
            if (selector === '') {
              this.$el.on(eventName, method);
            } else {
              this.$el.on(eventName, selector, method);
            }
          }
          return this;
        },
        undelegateEvents: function () {
          this.$el.off('.delegateEvents' + this.cid);
          return this;
        },
        _ensureElement: function () {
          if (!this.el) {
            var attrs = _.extend({}, _.result(this, 'attributes'));
            if (this.id)
              attrs.id = _.result(this, 'id');
            if (this.className)
              attrs['class'] = _.result(this, 'className');
            var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
            this.setElement($el, false);
          } else {
            this.setElement(_.result(this, 'el'), false);
          }
        }
      });
      Backbone.sync = function (method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
          emulateHTTP: Backbone.emulateHTTP,
          emulateJSON: Backbone.emulateJSON
        });
        var params = {
            type: type,
            dataType: 'json'
          };
        if (!options.url) {
          params.url = _.result(model, 'url') || urlError();
        }
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
          params.contentType = 'application/json';
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = 'application/x-www-form-urlencoded';
          params.data = params.data ? { model: params.data } : {};
        }
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
          params.type = 'POST';
          if (options.emulateJSON)
            params.data._method = type;
          var beforeSend = options.beforeSend;
          options.beforeSend = function (xhr) {
            xhr.setRequestHeader('X-HTTP-Method-Override', type);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== 'GET' && !options.emulateJSON) {
          params.processData = false;
        }
        if (params.type === 'PATCH' && noXhrPatch) {
          params.xhr = function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
          };
        }
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
      };
      var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent);
      var methodMap = {
          'create': 'POST',
          'update': 'PUT',
          'patch': 'PATCH',
          'delete': 'DELETE',
          'read': 'GET'
        };
      Backbone.ajax = function () {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
      };
      var Router = Backbone.Router = function (options) {
          options || (options = {});
          if (options.routes)
            this.routes = options.routes;
          this._bindRoutes();
          this.initialize.apply(this, arguments);
        };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _.extend(Router.prototype, Events, {
        initialize: function () {
        },
        route: function (route, name, callback) {
          if (!_.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_.isFunction(name)) {
            callback = name;
            name = '';
          }
          if (!callback)
            callback = this[name];
          var router = this;
          Backbone.history.route(route, function (fragment) {
            var args = router._extractParameters(route, fragment);
            router.execute(callback, args);
            router.trigger.apply(router, ['route:' + name].concat(args));
            router.trigger('route', name, args);
            Backbone.history.trigger('route', router, name, args);
          });
          return this;
        },
        execute: function (callback, args) {
          if (callback)
            callback.apply(this, args);
        },
        navigate: function (fragment, options) {
          Backbone.history.navigate(fragment, options);
          return this;
        },
        _bindRoutes: function () {
          if (!this.routes)
            return;
          this.routes = _.result(this, 'routes');
          var route, routes = _.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        _routeToRegExp: function (route) {
          route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
            return optional ? match : '([^/?]+)';
          }).replace(splatParam, '([^?]*?)');
          return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },
        _extractParameters: function (route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _.map(params, function (param, i) {
            if (i === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone.History = function () {
          this.handlers = [];
          _.bindAll(this, 'checkUrl');
          if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
          }
        };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var isExplorer = /msie [\w.]+/;
      var trailingSlash = /\/$/;
      var pathStripper = /#.*$/;
      History.started = false;
      _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function () {
          return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
        },
        getHash: function (window) {
          var match = (window || this).location.href.match(/#(.*)$/);
          return match ? match[1] : '';
        },
        getFragment: function (fragment, forcePushState) {
          if (fragment == null) {
            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
              fragment = decodeURI(this.location.pathname + this.location.search);
              var root = this.root.replace(trailingSlash, '');
              if (!fragment.indexOf(root))
                fragment = fragment.slice(root.length);
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, '');
        },
        start: function (options) {
          if (History.started)
            throw new Error('Backbone.history has already been started');
          History.started = true;
          this.options = _.extend({ root: '/' }, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
          var fragment = this.getFragment();
          var docMode = document.documentMode;
          var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
          this.root = ('/' + this.root + '/').replace(rootStripper, '/');
          if (oldIE && this._wantsHashChange) {
            var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
            this.iframe = frame.hide().appendTo('body')[0].contentWindow;
            this.navigate(fragment);
          }
          if (this._hasPushState) {
            Backbone.$(window).on('popstate', this.checkUrl);
          } else if (this._wantsHashChange && 'onhashchange' in window && !oldIE) {
            Backbone.$(window).on('hashchange', this.checkUrl);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          this.fragment = fragment;
          var loc = this.location;
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              this.fragment = this.getFragment(null, true);
              this.location.replace(this.root + '#' + this.fragment);
              return true;
            } else if (this._hasPushState && this.atRoot() && loc.hash) {
              this.fragment = this.getHash().replace(routeStripper, '');
              this.history.replaceState({}, document.title, this.root + this.fragment);
            }
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        stop: function () {
          Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        route: function (route, callback) {
          this.handlers.unshift({
            route: route,
            callback: callback
          });
        },
        checkUrl: function (e) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getFragment(this.getHash(this.iframe));
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        loadUrl: function (fragment) {
          fragment = this.fragment = this.getFragment(fragment);
          return _.any(this.handlers, function (handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        navigate: function (fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = { trigger: !!options };
          var url = this.root + (fragment = this.getFragment(fragment || ''));
          fragment = fragment.replace(pathStripper, '');
          if (this.fragment === fragment)
            return;
          this.fragment = fragment;
          if (fragment === '' && url !== '/')
            url = url.slice(0, -1);
          if (this._hasPushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
              if (!options.replace)
                this.iframe.document.open().close();
              this._updateHash(this.iframe.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        _updateHash: function (location, fragment, replace) {
          if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, '');
            location.replace(href + '#' + fragment);
          } else {
            location.hash = '#' + fragment;
          }
        }
      });
      Backbone.history = new History;
      var extend = function (protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, 'constructor')) {
          child = protoProps.constructor;
        } else {
          child = function () {
            return parent.apply(this, arguments);
          };
        }
        _.extend(child, parent, staticProps);
        var Surrogate = function () {
          this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;
        if (protoProps)
          _.extend(child.prototype, protoProps);
        child.__super__ = parent.prototype;
        return child;
      };
      Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
      var urlError = function () {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function (model, options) {
        var error = options.error;
        options.error = function (resp) {
          if (error)
            error(model, resp, options);
          model.trigger('error', model, resp, options);
        };
      };
      return Backbone;
    }));
  });
  require.define('/node_modules/underscore/underscore.js', function (module, exports, __dirname, __filename) {
    (function () {
      var root = this;
      var previousUnderscore = root._;
      var breaker = {};
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
      var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
      var _ = function (obj) {
        if (obj instanceof _)
          return obj;
        if (!(this instanceof _))
          return new _(obj);
        this._wrapped = obj;
      };
      if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
      _.VERSION = '1.6.0';
      var each = _.each = _.forEach = function (obj, iterator, context) {
          if (obj == null)
            return obj;
          if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
          } else if (obj.length === +obj.length) {
            for (var i = 0, length = obj.length; i < length; i++) {
              if (iterator.call(context, obj[i], i, obj) === breaker)
                return;
            }
          } else {
            var keys = _.keys(obj);
            for (var i = 0, length = keys.length; i < length; i++) {
              if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)
                return;
            }
          }
          return obj;
        };
      _.map = _.collect = function (obj, iterator, context) {
        var results = [];
        if (obj == null)
          return results;
        if (nativeMap && obj.map === nativeMap)
          return obj.map(iterator, context);
        each(obj, function (value, index, list) {
          results.push(iterator.call(context, value, index, list));
        });
        return results;
      };
      var reduceError = 'Reduce of empty array with no initial value';
      _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null)
          obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
          if (context)
            iterator = _.bind(iterator, context);
          return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function (value, index, list) {
          if (!initial) {
            memo = value;
            initial = true;
          } else {
            memo = iterator.call(context, memo, value, index, list);
          }
        });
        if (!initial)
          throw new TypeError(reduceError);
        return memo;
      };
      _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null)
          obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
          if (context)
            iterator = _.bind(iterator, context);
          return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
          var keys = _.keys(obj);
          length = keys.length;
        }
        each(obj, function (value, index, list) {
          index = keys ? keys[--length] : --length;
          if (!initial) {
            memo = obj[index];
            initial = true;
          } else {
            memo = iterator.call(context, memo, obj[index], index, list);
          }
        });
        if (!initial)
          throw new TypeError(reduceError);
        return memo;
      };
      _.find = _.detect = function (obj, predicate, context) {
        var result;
        any(obj, function (value, index, list) {
          if (predicate.call(context, value, index, list)) {
            result = value;
            return true;
          }
        });
        return result;
      };
      _.filter = _.select = function (obj, predicate, context) {
        var results = [];
        if (obj == null)
          return results;
        if (nativeFilter && obj.filter === nativeFilter)
          return obj.filter(predicate, context);
        each(obj, function (value, index, list) {
          if (predicate.call(context, value, index, list))
            results.push(value);
        });
        return results;
      };
      _.reject = function (obj, predicate, context) {
        return _.filter(obj, function (value, index, list) {
          return !predicate.call(context, value, index, list);
        }, context);
      };
      _.every = _.all = function (obj, predicate, context) {
        predicate || (predicate = _.identity);
        var result = true;
        if (obj == null)
          return result;
        if (nativeEvery && obj.every === nativeEvery)
          return obj.every(predicate, context);
        each(obj, function (value, index, list) {
          if (!(result = result && predicate.call(context, value, index, list)))
            return breaker;
        });
        return !!result;
      };
      var any = _.some = _.any = function (obj, predicate, context) {
          predicate || (predicate = _.identity);
          var result = false;
          if (obj == null)
            return result;
          if (nativeSome && obj.some === nativeSome)
            return obj.some(predicate, context);
          each(obj, function (value, index, list) {
            if (result || (result = predicate.call(context, value, index, list)))
              return breaker;
          });
          return !!result;
        };
      _.contains = _.include = function (obj, target) {
        if (obj == null)
          return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf)
          return obj.indexOf(target) != -1;
        return any(obj, function (value) {
          return value === target;
        });
      };
      _.invoke = function (obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function (value) {
          return (isFunc ? method : value[method]).apply(value, args);
        });
      };
      _.pluck = function (obj, key) {
        return _.map(obj, _.property(key));
      };
      _.where = function (obj, attrs) {
        return _.filter(obj, _.matches(attrs));
      };
      _.findWhere = function (obj, attrs) {
        return _.find(obj, _.matches(attrs));
      };
      _.max = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.max.apply(Math, obj);
        }
        var result = -Infinity, lastComputed = -Infinity;
        each(obj, function (value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          if (computed > lastComputed) {
            result = value;
            lastComputed = computed;
          }
        });
        return result;
      };
      _.min = function (obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.min.apply(Math, obj);
        }
        var result = Infinity, lastComputed = Infinity;
        each(obj, function (value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          if (computed < lastComputed) {
            result = value;
            lastComputed = computed;
          }
        });
        return result;
      };
      _.shuffle = function (obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function (value) {
          rand = _.random(index++);
          shuffled[index - 1] = shuffled[rand];
          shuffled[rand] = value;
        });
        return shuffled;
      };
      _.sample = function (obj, n, guard) {
        if (n == null || guard) {
          if (obj.length !== +obj.length)
            obj = _.values(obj);
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
      var lookupIterator = function (value) {
        if (value == null)
          return _.identity;
        if (_.isFunction(value))
          return value;
        return _.property(value);
      };
      _.sortBy = function (obj, iterator, context) {
        iterator = lookupIterator(iterator);
        return _.pluck(_.map(obj, function (value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iterator.call(context, value, index, list)
          };
        }).sort(function (left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0)
              return 1;
            if (a < b || b === void 0)
              return -1;
          }
          return left.index - right.index;
        }), 'value');
      };
      var group = function (behavior) {
        return function (obj, iterator, context) {
          var result = {};
          iterator = lookupIterator(iterator);
          each(obj, function (value, index) {
            var key = iterator.call(context, value, index, obj);
            behavior(result, key, value);
          });
          return result;
        };
      };
      _.groupBy = group(function (result, key, value) {
        _.has(result, key) ? result[key].push(value) : result[key] = [value];
      });
      _.indexBy = group(function (result, key, value) {
        result[key] = value;
      });
      _.countBy = group(function (result, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
      });
      _.sortedIndex = function (array, obj, iterator, context) {
        iterator = lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
          var mid = low + high >>> 1;
          iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
      };
      _.toArray = function (obj) {
        if (!obj)
          return [];
        if (_.isArray(obj))
          return slice.call(obj);
        if (obj.length === +obj.length)
          return _.map(obj, _.identity);
        return _.values(obj);
      };
      _.size = function (obj) {
        if (obj == null)
          return 0;
        return obj.length === +obj.length ? obj.length : _.keys(obj).length;
      };
      _.first = _.head = _.take = function (array, n, guard) {
        if (array == null)
          return void 0;
        if (n == null || guard)
          return array[0];
        if (n < 0)
          return [];
        return slice.call(array, 0, n);
      };
      _.initial = function (array, n, guard) {
        return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
      };
      _.last = function (array, n, guard) {
        if (array == null)
          return void 0;
        if (n == null || guard)
          return array[array.length - 1];
        return slice.call(array, Math.max(array.length - n, 0));
      };
      _.rest = _.tail = _.drop = function (array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
      _.compact = function (array) {
        return _.filter(array, _.identity);
      };
      var flatten = function (input, shallow, output) {
        if (shallow && _.every(input, _.isArray)) {
          return concat.apply(output, input);
        }
        each(input, function (value) {
          if (_.isArray(value) || _.isArguments(value)) {
            shallow ? push.apply(output, value) : flatten(value, shallow, output);
          } else {
            output.push(value);
          }
        });
        return output;
      };
      _.flatten = function (array, shallow) {
        return flatten(array, shallow, []);
      };
      _.without = function (array) {
        return _.difference(array, slice.call(arguments, 1));
      };
      _.partition = function (array, predicate) {
        var pass = [], fail = [];
        each(array, function (elem) {
          (predicate(elem) ? pass : fail).push(elem);
        });
        return [
          pass,
          fail
        ];
      };
      _.uniq = _.unique = function (array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
          context = iterator;
          iterator = isSorted;
          isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function (value, index) {
          if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
            seen.push(value);
            results.push(array[index]);
          }
        });
        return results;
      };
      _.union = function () {
        return _.uniq(_.flatten(arguments, true));
      };
      _.intersection = function (array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function (item) {
          return _.every(rest, function (other) {
            return _.contains(other, item);
          });
        });
      };
      _.difference = function (array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function (value) {
          return !_.contains(rest, value);
        });
      };
      _.zip = function () {
        var length = _.max(_.pluck(arguments, 'length').concat(0));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
          results[i] = _.pluck(arguments, '' + i);
        }
        return results;
      };
      _.object = function (list, values) {
        if (list == null)
          return {};
        var result = {};
        for (var i = 0, length = list.length; i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
      _.indexOf = function (array, item, isSorted) {
        if (array == null)
          return -1;
        var i = 0, length = array.length;
        if (isSorted) {
          if (typeof isSorted == 'number') {
            i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
          } else {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
          }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf)
          return array.indexOf(item, isSorted);
        for (; i < length; i++)
          if (array[i] === item)
            return i;
        return -1;
      };
      _.lastIndexOf = function (array, item, from) {
        if (array == null)
          return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
          return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = hasIndex ? from : array.length;
        while (i--)
          if (array[i] === item)
            return i;
        return -1;
      };
      _.range = function (start, stop, step) {
        if (arguments.length <= 1) {
          stop = start || 0;
          start = 0;
        }
        step = arguments[2] || 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while (idx < length) {
          range[idx++] = start;
          start += step;
        }
        return range;
      };
      var ctor = function () {
      };
      _.bind = function (func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind)
          return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func))
          throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function () {
          if (!(this instanceof bound))
            return func.apply(context, args.concat(slice.call(arguments)));
          ctor.prototype = func.prototype;
          var self = new ctor;
          ctor.prototype = null;
          var result = func.apply(self, args.concat(slice.call(arguments)));
          if (Object(result) === result)
            return result;
          return self;
        };
      };
      _.partial = function (func) {
        var boundArgs = slice.call(arguments, 1);
        return function () {
          var position = 0;
          var args = boundArgs.slice();
          for (var i = 0, length = args.length; i < length; i++) {
            if (args[i] === _)
              args[i] = arguments[position++];
          }
          while (position < arguments.length)
            args.push(arguments[position++]);
          return func.apply(this, args);
        };
      };
      _.bindAll = function (obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0)
          throw new Error('bindAll must be passed function names');
        each(funcs, function (f) {
          obj[f] = _.bind(obj[f], obj);
        });
        return obj;
      };
      _.memoize = function (func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function () {
          var key = hasher.apply(this, arguments);
          return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
        };
      };
      _.delay = function (func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function () {
          return func.apply(null, args);
        }, wait);
      };
      _.defer = function (func) {
        return _.delay.apply(_, [
          func,
          1
        ].concat(slice.call(arguments, 1)));
      };
      _.throttle = function (func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function () {
          previous = options.leading === false ? 0 : _.now();
          timeout = null;
          result = func.apply(context, args);
          context = args = null;
        };
        return function () {
          var now = _.now();
          if (!previous && options.leading === false)
            previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
            context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
      _.debounce = function (func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        var later = function () {
          var last = _.now() - timestamp;
          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        };
        return function () {
          context = this;
          args = arguments;
          timestamp = _.now();
          var callNow = immediate && !timeout;
          if (!timeout) {
            timeout = setTimeout(later, wait);
          }
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        };
      };
      _.once = function (func) {
        var ran = false, memo;
        return function () {
          if (ran)
            return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      };
      _.wrap = function (func, wrapper) {
        return _.partial(wrapper, func);
      };
      _.compose = function () {
        var funcs = arguments;
        return function () {
          var args = arguments;
          for (var i = funcs.length - 1; i >= 0; i--) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      };
      _.after = function (times, func) {
        return function () {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
      _.keys = function (obj) {
        if (!_.isObject(obj))
          return [];
        if (nativeKeys)
          return nativeKeys(obj);
        var keys = [];
        for (var key in obj)
          if (_.has(obj, key))
            keys.push(key);
        return keys;
      };
      _.values = function (obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = new Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
      _.pairs = function (obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = new Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [
            keys[i],
            obj[keys[i]]
          ];
        }
        return pairs;
      };
      _.invert = function (obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
      _.functions = _.methods = function (obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key]))
            names.push(key);
        }
        return names.sort();
      };
      _.extend = function (obj) {
        each(slice.call(arguments, 1), function (source) {
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.pick = function (obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function (key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      };
      _.omit = function (obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
          if (!_.contains(keys, key))
            copy[key] = obj[key];
        }
        return copy;
      };
      _.defaults = function (obj) {
        each(slice.call(arguments, 1), function (source) {
          if (source) {
            for (var prop in source) {
              if (obj[prop] === void 0)
                obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.clone = function (obj) {
        if (!_.isObject(obj))
          return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
      _.tap = function (obj, interceptor) {
        interceptor(obj);
        return obj;
      };
      var eq = function (a, b, aStack, bStack) {
        if (a === b)
          return a !== 0 || 1 / a == 1 / b;
        if (a == null || b == null)
          return a === b;
        if (a instanceof _)
          a = a._wrapped;
        if (b instanceof _)
          b = b._wrapped;
        var className = toString.call(a);
        if (className != toString.call(b))
          return false;
        switch (className) {
        case '[object String]':
          return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object')
          return false;
        var length = aStack.length;
        while (length--) {
          if (aStack[length] == a)
            return bStack[length] == b;
        }
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        if (className == '[object Array]') {
          size = a.length;
          result = size == b.length;
          if (result) {
            while (size--) {
              if (!(result = eq(a[size], b[size], aStack, bStack)))
                break;
            }
          }
        } else {
          for (var key in a) {
            if (_.has(a, key)) {
              size++;
              if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
                break;
            }
          }
          if (result) {
            for (key in b) {
              if (_.has(b, key) && !size--)
                break;
            }
            result = !size;
          }
        }
        aStack.pop();
        bStack.pop();
        return result;
      };
      _.isEqual = function (a, b) {
        return eq(a, b, [], []);
      };
      _.isEmpty = function (obj) {
        if (obj == null)
          return true;
        if (_.isArray(obj) || _.isString(obj))
          return obj.length === 0;
        for (var key in obj)
          if (_.has(obj, key))
            return false;
        return true;
      };
      _.isElement = function (obj) {
        return !!(obj && obj.nodeType === 1);
      };
      _.isArray = nativeIsArray || function (obj) {
        return toString.call(obj) == '[object Array]';
      };
      _.isObject = function (obj) {
        return obj === Object(obj);
      };
      each([
        'Arguments',
        'Function',
        'String',
        'Number',
        'Date',
        'RegExp'
      ], function (name) {
        _['is' + name] = function (obj) {
          return toString.call(obj) == '[object ' + name + ']';
        };
      });
      if (!_.isArguments(arguments)) {
        _.isArguments = function (obj) {
          return !!(obj && _.has(obj, 'callee'));
        };
      }
      if (typeof /./ !== 'function') {
        _.isFunction = function (obj) {
          return typeof obj === 'function';
        };
      }
      _.isFinite = function (obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
      _.isNaN = function (obj) {
        return _.isNumber(obj) && obj != +obj;
      };
      _.isBoolean = function (obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
      };
      _.isNull = function (obj) {
        return obj === null;
      };
      _.isUndefined = function (obj) {
        return obj === void 0;
      };
      _.has = function (obj, key) {
        return hasOwnProperty.call(obj, key);
      };
      _.noConflict = function () {
        root._ = previousUnderscore;
        return this;
      };
      _.identity = function (value) {
        return value;
      };
      _.constant = function (value) {
        return function () {
          return value;
        };
      };
      _.property = function (key) {
        return function (obj) {
          return obj[key];
        };
      };
      _.matches = function (attrs) {
        return function (obj) {
          if (obj === attrs)
            return true;
          for (var key in attrs) {
            if (attrs[key] !== obj[key])
              return false;
          }
          return true;
        };
      };
      _.times = function (n, iterator, context) {
        var accum = Array(Math.max(0, n));
        for (var i = 0; i < n; i++)
          accum[i] = iterator.call(context, i);
        return accum;
      };
      _.random = function (min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
      _.now = Date.now || function () {
        return new Date().getTime();
      };
      var entityMap = {
          escape: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;'
          }
        };
      entityMap.unescape = _.invert(entityMap.escape);
      var entityRegexes = {
          escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
          unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
        };
      _.each([
        'escape',
        'unescape'
      ], function (method) {
        _[method] = function (string) {
          if (string == null)
            return '';
          return ('' + string).replace(entityRegexes[method], function (match) {
            return entityMap[method][match];
          });
        };
      });
      _.result = function (object, property) {
        if (object == null)
          return void 0;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
      };
      _.mixin = function (obj) {
        each(_.functions(obj), function (name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function () {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return result.call(this, func.apply(_, args));
          };
        });
      };
      var idCounter = 0;
      _.uniqueId = function (prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      };
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
          "'": "'",
          '\\': '\\',
          '\r': 'r',
          '\n': 'n',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
      _.template = function (text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = new RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
          ].join('|') + '|$', 'g');
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, function (match) {
            return '\\' + escapes[match];
          });
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        if (!settings.variable)
          source = 'with(obj||{}){\n' + source + '}\n';
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
        try {
          render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
          e.source = source;
          throw e;
        }
        if (data)
          return render(data, _);
        var template = function (data) {
          return render.call(this, data, _);
        };
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
        return template;
      };
      _.chain = function (obj) {
        return _(obj).chain();
      };
      var result = function (obj) {
        return this._chain ? _(obj).chain() : obj;
      };
      _.mixin(_);
      each([
        'pop',
        'push',
        'reverse',
        'shift',
        'sort',
        'splice',
        'unshift'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name == 'shift' || name == 'splice') && obj.length === 0)
            delete obj[0];
          return result.call(this, obj);
        };
      });
      each([
        'concat',
        'join',
        'slice'
      ], function (name) {
        var method = ArrayProto[name];
        _.prototype[name] = function () {
          return result.call(this, method.apply(this._wrapped, arguments));
        };
      });
      _.extend(_.prototype, {
        chain: function () {
          this._chain = true;
          return this;
        },
        value: function () {
          return this._wrapped;
        }
      });
      if (typeof define === 'function' && define.amd) {
        define('underscore', [], function () {
          return _;
        });
      }
    }.call(this));
  });
  require.define('/components/search/results.client.js', function (module, exports, __dirname, __filename) {
    var Collection = require('/node_modules/backbone/backbone.js', module).Collection, fetch = Collection.prototype.fetch;
    module.exports = Collection.extend({
      url: '/search',
      fetch: function (parsedSearch) {
        return fetch.call(this, {
          data: parsedSearch,
          reset: true,
          type: 'POST'
        });
      }
    });
  });
  require.define('/components/search/result.client.js', function (module, exports, __dirname, __filename) {
    var Backbone = require('/node_modules/backbone/backbone.js', module);
    module.exports = Backbone.Model.extend({});
  });
  require.define('/components/search/parser.js', function (module, exports, __dirname, __filename) {
    module.exports = function () {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
      }
      function SyntaxError(message, expected, found, offset, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset;
        this.line = line;
        this.column = column;
        this.name = 'SyntaxError';
      }
      peg$subclass(SyntaxError, Error);
      function parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = 'shows', peg$c1 = {
            type: 'literal',
            value: 'shows',
            description: '"shows"'
          }, peg$c2 = 'songs', peg$c3 = {
            type: 'literal',
            value: 'songs',
            description: '"songs"'
          }, peg$c4 = 'venues', peg$c5 = {
            type: 'literal',
            value: 'venues',
            description: '"venues"'
          }, peg$c6 = 'show', peg$c7 = {
            type: 'literal',
            value: 'show',
            description: '"show"'
          }, peg$c8 = 'song', peg$c9 = {
            type: 'literal',
            value: 'song',
            description: '"song"'
          }, peg$c10 = 'venue', peg$c11 = {
            type: 'literal',
            value: 'venue',
            description: '"venue"'
          }, peg$c12 = 'between', peg$c13 = {
            type: 'literal',
            value: 'between',
            description: '"between"'
          }, peg$c14 = 'in', peg$c15 = {
            type: 'literal',
            value: 'in',
            description: '"in"'
          }, peg$c16 = 'sort', peg$c17 = {
            type: 'literal',
            value: 'sort',
            description: '"sort"'
          }, peg$c18 = 'first', peg$c19 = {
            type: 'literal',
            value: 'first',
            description: '"first"'
          }, peg$c20 = 'last', peg$c21 = {
            type: 'literal',
            value: 'last',
            description: '"last"'
          }, peg$c22 = peg$FAILED, peg$c23 = null, peg$c24 = function (q, ce, fe) {
            return extend(ce, q, fe);
          }, peg$c25 = function (cm, arg) {
            return extendWithArguments(cm, arg);
          }, peg$c26 = function (match) {
            return { command: match.trim() };
          }, peg$c27 = function (qm, arg) {
            return { qualifier: extendWithArguments(qm, arg) };
          }, peg$c28 = function (match) {
            return { qualifier: match.trim() };
          }, peg$c29 = [], peg$c30 = function (fes) {
            return { filters: fes };
          }, peg$c31 = function (fm, arg) {
            return extend(fm, arg);
          }, peg$c32 = function (match) {
            return { filter: match.trim() };
          }, peg$c33 = function (args) {
            return { arguments: args };
          }, peg$c34 = void 0, peg$c35 = function (match) {
            return match;
          }, peg$c36 = /^[^'"]/, peg$c37 = {
            type: 'class',
            value: '[^\'"]',
            description: '[^\'"]'
          }, peg$c38 = function (match) {
            return match.match(/^['"](.+)['"]$/)[1];
          }, peg$c39 = "'", peg$c40 = {
            type: 'literal',
            value: "'",
            description: '"\'"'
          }, peg$c41 = '"', peg$c42 = {
            type: 'literal',
            value: '"',
            description: '"\\""'
          }, peg$c43 = /^[a-zA-Z0-9_\-]/, peg$c44 = {
            type: 'class',
            value: '[a-zA-Z0-9_\\-]',
            description: '[a-zA-Z0-9_\\-]'
          }, peg$c45 = /^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/, peg$c46 = {
            type: 'class',
            value: '[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]',
            description: '[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]'
          }, peg$c47 = '\n', peg$c48 = {
            type: 'literal',
            value: '\n',
            description: '"\\n"'
          }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = {
            line: 1,
            column: 1,
            seenCR: false
          }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ('startRule' in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error('Can\'t start parsing from rule "' + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }
        function offset() {
          return peg$reportedPos;
        }
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function expected(description) {
          throw peg$buildException(null, [{
              type: 'other',
              description: description
            }], peg$reportedPos);
        }
        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p, ch;
            for (p = startPos; p < endPos; p++) {
              ch = input.charAt(p);
              if (ch === '\n') {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
              };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildException(message, expected, pos) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function (a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function (ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function (ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(', ') + ' or ' + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input';
            return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
        }
        function peg$parsestart() {
          var s0;
          s0 = peg$parsesearchExpression();
          return s0;
        }
        function peg$parsecommandKeywords() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c0) {
            s1 = peg$c0;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c1);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c2) {
              s1 = peg$c2;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 6) === peg$c4) {
                s1 = peg$c4;
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c5);
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c6) {
              s1 = peg$c6;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c7);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c8) {
                s1 = peg$c8;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c9);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c10) {
                  s1 = peg$c10;
                  peg$currPos += 5;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c11);
                  }
                }
              }
            }
            if (s1 !== peg$FAILED) {
              s1 = input.substring(s0, peg$currPos);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parsefilterKeywords() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c12) {
            s1 = peg$c12;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c13);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c14) {
              s1 = peg$c14;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c15);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c16) {
                s1 = peg$c16;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsequalifiers() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c18) {
            s1 = peg$c18;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c19);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c20) {
              s1 = peg$c20;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c21);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsereserved() {
          var s0;
          s0 = peg$parsecommandKeywords();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefilterKeywords();
            if (s0 === peg$FAILED) {
              s0 = peg$parsequalifiers();
            }
          }
          return s0;
        }
        function peg$parsesearchExpression() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parsequalifierExpr();
          if (s1 === peg$FAILED) {
            s1 = peg$c23;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsecommandExpr();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsefilterExprs();
              if (s3 === peg$FAILED) {
                s3 = peg$c23;
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c24(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c22;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c22;
          }
          return s0;
        }
        function peg$parsecommandExpr() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsecommandMatch();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearguments();
            if (s2 === peg$FAILED) {
              s2 = peg$c23;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c25(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c22;
          }
          return s0;
        }
        function peg$parsecommandMatch() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsecommandKeywords();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s3 = [
                  s3,
                  s4,
                  s5
                ];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c22;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c22;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c22;
          }
          if (s2 !== peg$FAILED) {
            s2 = input.substring(s1, peg$currPos);
          }
          s1 = s2;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsequalifierExpr() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsequalifierMatch();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearguments();
            if (s2 === peg$FAILED) {
              s2 = peg$c23;
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c27(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c22;
          }
          return s0;
        }
        function peg$parsequalifierMatch() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsequalifiers();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s3 = [
                  s3,
                  s4,
                  s5
                ];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c22;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c22;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c22;
          }
          if (s2 !== peg$FAILED) {
            s2 = input.substring(s1, peg$currPos);
          }
          s1 = s2;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c28(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsefilterExprs() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsefilterExpr();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsefilterExpr();
            }
          } else {
            s1 = peg$c22;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c30(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsefilterExpr() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsefilterMatch();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsearguments();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c31(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c22;
          }
          return s0;
        }
        function peg$parsefilterMatch() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsefilterKeywords();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s3 = [
                  s3,
                  s4,
                  s5
                ];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c22;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c22;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c22;
          }
          if (s2 !== peg$FAILED) {
            s2 = input.substring(s1, peg$currPos);
          }
          s1 = s2;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c32(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsearguments() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseargumentMatch();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseargumentMatch();
            }
          } else {
            s1 = peg$c22;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c33(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseargumentMatch() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parsereserved();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c34;
          } else {
            peg$currPos = s1;
            s1 = peg$c22;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseword();
            if (s3 !== peg$FAILED) {
              s3 = input.substring(s2, peg$currPos);
            }
            s2 = s3;
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c35(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c22;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c22;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsestringLiteral();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c35(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c22;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c22;
            }
          }
          return s0;
        }
        function peg$parsestringLiteral() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parsequote();
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c36.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c36.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                  }
                }
              }
            } else {
              s4 = peg$c22;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsequote();
              if (s5 !== peg$FAILED) {
                s3 = [
                  s3,
                  s4,
                  s5
                ];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c22;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c22;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c22;
          }
          if (s2 !== peg$FAILED) {
            s2 = input.substring(s1, peg$currPos);
          }
          s1 = s2;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c38(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsequote() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c39;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c41;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseword() {
          var s0, s1;
          s0 = [];
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              if (peg$c43.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c44);
                }
              }
            }
          } else {
            s0 = peg$c22;
          }
          return s0;
        }
        function peg$parse__() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parsewhitespace();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsewhitespace();
            }
          } else {
            s1 = peg$c22;
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
          return s0;
        }
        function peg$parse_() {
          var s0;
          s0 = peg$parse__();
          if (s0 === peg$FAILED) {
            s0 = peg$c23;
          }
          return s0;
        }
        function peg$parsewhitespace() {
          var s0;
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c47;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
          }
          return s0;
        }
        var slice = [].slice, hasOwn = {}.hasOwnProperty;
        function has(obj, key) {
          return hasOwn.call(obj, key);
        }
        function extend(first) {
          var i, ref, prop, rest = slice.call(arguments, 1), len = rest.length;
          for (i = 0; i < len; i++) {
            ref = rest[i];
            for (prop in ref)
              has(ref, prop) && (first[prop] = ref[prop]);
          }
          return first;
        }
        function extendWithArguments() {
          var args = [{ arguments: [] }].concat(slice.call(arguments));
          return extend.apply(null, args);
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: 'end',
              description: 'end of input'
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError: SyntaxError,
        parse: parse
      };
    }();
  });
  require.define('/components/search/views/form.js', function (module, exports, __dirname, __filename) {
    var Backbone = require('/node_modules/backbone/backbone.js', module), Form = require('/components/search/views/react/form.js', module), isEmpty = require('/node_modules/underscore/underscore.js', module).isEmpty;
    module.exports = Backbone.View.extend({
      render: function () {
        React.renderComponent(Form({ onSubmit: this.onSubmit.bind(this) }), this.$el[0]);
      },
      onSubmit: function (value) {
        if (isEmpty(value))
          console.log('empty');
        else
          this.trigger('submit', value);
      }
    });
  });
  require.define('/components/search/views/react/form.js', function (module, exports, __dirname, __filename) {
    module.exports = React.createClass({
      displayName: 'exports',
      handleKeyPress: function (e) {
        if ('Enter' !== e.key)
          return;
        e.preventDefault();
        this.props.onSubmit(e.target.value);
      },
      render: function () {
        return React.DOM.form({
          autoComplete: 'off',
          onKeyPress: this.handleKeyPress
        }, React.DOM.span({ className: 'fui-search search-icon' }), React.DOM.label({ htmlFor: 'search' }, 'Search'), React.DOM.input({
          autoFocus: true,
          autoCapitalize: 'off',
          id: 'search',
          placeholder: 'all shows in 1997',
          type: 'text'
        }));
      }
    });
  });
  require('/components/search/index.client.js');
}.call(this, this));